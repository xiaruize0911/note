#高斯消元 

考虑对一边的人标 $1$ 另一边标 $0$

考虑对于每一个人，如果这个人当前有奇数个连边，考虑连一条自环，使得它变为偶数个连边

将每个点所有的连接的点的点值 $xor$ 起来，如果当前为奇数，那么使异或和为 $1$ 否则为 $0$

解出一个这样的情况可以直接高斯消元，用 ``bitset`` 优化可以做到 $\mathcal{O}(\frac{n^2}{\omega})$ 的时间复杂度，可以通过 $n\leq 10^3$ 的点

```cpp
// Author: xiaruize
#ifndef ONLINE_JUDGE
bool start_of_memory_use;
#endif
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
clock_t start_clock = clock();
#endif
#define int long long
#define ull unsigned long long
#define ALL(a) (a).begin(), (a).end()
#define pb push_back
#define mk make_pair
#define pii pair<int, int>
#define pis pair<int, string>
#define sec second
#define fir first
#define sz(a) int((a).size())
#define Yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define No cout << "No" << endl
#define NO cout << "NO" << endl
#define mms(arr, n) memset(arr, n, sizeof(arr))
#define rep(i, a, n) for (int i = (a); i <= (n); ++i)
#define per(i, n, a) for (int i = (n); i >= (a); --i)
int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}
int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MOD = 1000000007;
const int N = 2e2 + 10;

bitset<N> bt[N];
int n;

void solve()
{
	cin >> n;
	rep(i, 1, n)
	{
		int x;
		cin >> x;
		bt[i][i] = bt[i][n + 1] = (x & 1);
		rep(j, 1, x)
		{
			int v;
			cin >> v;
			bt[i][v] = true;
		}
	}
	rep(i, 1, n)
	{
		int p = i;
		while (!bt[p][i] && p <= n)
			p++;
		if (p > n)
			continue;
		swap(bt[i], bt[p]);
		rep(j, 1, n)

		{
			if (i == j)
				continue;
			if (bt[j][i])
				bt[j] ^= bt[i];
		}
	}
	vector<int> res;
	rep(i, 1, n) if (bt[i][i] && bt[i][n + 1]) res.push_back(i);
	cout << res.size() << endl;
	for (auto v : res)
		cout << v << ' ';
}

#ifndef ONLINE_JUDGE
bool end_of_memory_use;
#endif

signed main()
{
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int testcase = 1;
	// cin >> testcase;
	while (testcase--)
		solve();
#ifndef ONLINE_JUDGE
	cerr << "Memory use:" << (&end_of_memory_use - &start_of_memory_use) / 1024.0 / 1024.0 << "MiB" << endl;
	cerr << "Time use:" << (double)clock() / CLOCKS_PER_SEC * 1000.0 << "ms" << endl;
#endif
	return 0;
}
```