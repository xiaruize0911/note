#欧拉路径 #数学 

考虑转化题面，在 $u\rightarrow v$ 建边，得到一个图

原题意等价于求在这个图中至少加多少条边使得图中有一条欧拉路径（经过所有边的路径）

$$
res=\sum \limits_{u\in G}max(indegree_u,outdegree_u)+\text{原图欧拉回路个数}
$$

这个 $dfs$ 就可以求

解释一下为什么：

前面的部分为，每个点每次进入必然伴随出去，所以两者取 $max$

后面的欧拉回路个数，是因为加边的时候，在这个子图中，一条边不可能同时贡献为出入的边和连接两个联通块的边，所以这条边只用来连接联通块，而不连接欧拉回路的边可以同时产生 $2$ 种贡献

```cpp
// Author: xiaruize
#ifndef ONLINE_JUDGE
#define debug(x) cerr << "On Line:" << __LINE__ << #x << "=" << x << endl
bool start_of_memory_use;
#else
#define debug(x)
#endif
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
clock_t start_clock = clock();
#endif
#define int long long
#define ull unsigned long long
#define ALL(a) (a).begin(), (a).end()
#define pb push_back
#define mk make_pair
#define pii pair<int, int>
#define pis pair<int, string>
#define sec second
#define fir first
#define sz(a) int((a).size())
#define Yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define No cout << "No" << endl
#define NO cout << "NO" << endl
#define mms(arr, n) memset(arr, n, sizeof(arr))
#define rep(i, a, n) for (int i = (a); i <= (n); ++i)
#define per(i, n, a) for (int i = (n); i >= (a); --i)
int max(int a, int b)

{
	if (a > b)
		return a;
	return b;
}
int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MOD = 1000000007;
const int N = 2e5 + 10;

int n, m;
int indeg[N], outdeg[N];
vector<int> g[N];
bool st[N], vis[N], c[N];
int res = 0;

void dfs(int x, int rt)
{
	if (vis[x])
		return;
	vis[x] = true;
	if (indeg[x] != outdeg[x])
		c[rt] = false;
	for (auto v : g[x])
	{
		dfs(v, rt);
	}
}

void solve()
{
	cin >> m;
	rep(i, 1, m)
	{
		int u, v;
		cin >> u >> v;
		indeg[u]++;
		outdeg[v]++;
		g[u].push_back(v);
		g[v].push_back(u);
		st[u] = st[v] = true;
		n = max(n, max(u, v));
	}
	rep(i, 1, n)
	{
		if (st[i] && !vis[i])
		{
			c[i] = true;
			dfs(i, i);
		}
		if (st[i])
			res += max(indeg[i], outdeg[i]) + c[i];
	}
	cout << res << endl;
}

#ifndef ONLINE_JUDGE
bool end_of_memory_use;
#endif

signed main()
{
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int testcase = 1;
	// cin >> testcase;
	while (testcase--)
		solve();
#ifndef ONLINE_JUDGE
	cerr << "Memory use:" << (&end_of_memory_use - &start_of_memory_use) / 1024.0 / 1024.0 << "MiB" << endl;
	cerr << "Time use:" << (double)clock() / CLOCKS_PER_SEC * 1000.0 << "ms" << endl;
#endif
	return 0;
}
```