#博弈论  #阶梯博弈

对于每一个 $a_i$ ，转化为它到 $m-2$ 的间隔数，然后发现这个等价于阶梯博弈

阶梯博弈只考虑奇数位，但是同时也要考虑操作完偶数位以后是必败状态的情况

注意如果一开始在 $m-2$ 上有数，那么必胜一定是先取这些数

```cpp
// Author: xiaruize
#ifndef ONLINE_JUDGE
bool start_of_memory_use;
#endif
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
clock_t start_clock = clock();
#endif
#define int long long
#define ull unsigned long long
#define ALL(a) (a).begin(), (a).end()
#define pb push_back
#define mk make_pair
#define pii pair<int, int>
#define pis pair<int, string>
#define sec second
#define fir first
#define sz(a) int((a).size())
#define Yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define No cout << "No" << endl
#define NO cout << "NO" << endl
#define mms(arr, n) memset(arr, n, sizeof(arr))
#define rep(i, a, n) for (int i = (a); i <= (n); ++i)
#define per(i, n, a) for (int i = (n); i >= (a); --i)
int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}
int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MOD = 1000000007;
const int N = 1e6 + 10;

int n, m;
int a[N], sg[N << 2], tot;

void solve()
{
	cin >> m >> n;
	rep(i, 1, n) cin >> a[i];
	if (a[n] == m - 1)
	{
		int res = 0;
		rep(i, 1, n) res += (a[i] == m - n + i - 1);
		cout << res << endl;
		return;
	}
	a[n + 1] = m - 1;
	per(i, n, 1)
	{
		if (a[i] == a[i + 1] - 1)
			sg[tot]++;
		else if (a[i] == a[i + 1] - 2)
			sg[++tot]++;
		else if ((a[i + 1] - a[i]) & 1)
			sg[tot += 2]++;
		else
			sg[tot += 3]++;
	}
	int cur = 0;
	for (int i = 1; i <= tot; i += 2)
		cur ^= sg[i];
	if (!cur)
	{
		cout << "0" << endl;
		return;
	}
	int res = 0;
	for (int i = 1; i <= tot; i += 2)
	{
		if ((sg[i] ^ cur) < sg[i])
			res++;
		if (i != tot && (sg[i] ^ cur) > sg[i] && sg[i + 1] >= (sg[i] ^ cur) - sg[i])
			res++;
	}
	cout << res << endl;
}

#ifndef ONLINE_JUDGE
bool end_of_memory_use;
#endif

signed main()
{
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int testcase = 1;
	// cin >> testcase;
	while (testcase--)
		solve();
#ifndef ONLINE_JUDGE
	cerr << "Memory use:" << (&end_of_memory_use - &start_of_memory_use) / 1024.0 / 1024.0 << "MiB" << endl;
	cerr << "Time use:" << (double)clock() / CLOCKS_PER_SEC * 1000.0 << "ms" << endl;
#endif
	return 0;
}
```