#贪心 
询问操作等价于将当前的子树从一个点分为几棵树，类似于点分治的操作

所以询问可以转化为原树的最小点分树的大小

然后考虑对于每个点计算一个 $f_x$ 表示答案，$s_x$ 状压一个子树内的所有答案

因为点分治最多 $O(logn)$ 层，所以状压 $16$ 位即可

当前点的值应该为最小的下面有两次出现的值

```cpp
// Author: xiaruize
#ifndef ONLINE_JUDGE
bool start_of_memory_use;
#endif
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
clock_t start_clock = clock();
#endif
#define int long long
#define ull unsigned long long
#define ALL(a) (a).begin(), (a).end()
#define pb push_back
#define mk make_pair
#define pii pair<int, int>
#define pis pair<int, string>
#define sec second
#define fir first
#define sz(a) int((a).size())
#define Yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define No cout << "No" << endl
#define NO cout << "NO" << endl
#define mms(arr, n) memset(arr, n, sizeof(arr))
#define rep(i, a, n) for (int i = (a); i <= (n); ++i)
#define per(i, n, a) for (int i = (n); i >= (a); --i)
int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}
int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MOD = 1000000007;
const int N = 2e5 + 10;

int n;
vector<int> g[N];
int res, s[N];
int lg[N];

void dfs(int x, int fa)
{
	int bn = 0, msk = 0;
	if (g[x].size() == 1 && fa)
	{
		s[x] = 1;
		return;
	}
	for (auto v : g[x])
	{
		if (v == fa)
			continue;
		dfs(v, x);
		msk |= (bn & s[v]);
		bn |= s[v];
	}
	// cerr << msk << ' ' << bn << endl;
	msk = ((1 << 16) - (1 << (!msk ? 0 : __lg(msk)))) & (((1 << 16) - 1) ^ bn);
	int cur = 0;
	if (!msk)
		cur = __lg(n) + 1;
	else
		cur = __lg(msk & -msk);
	s[x] = (bn & ((1 << 16) - (1 << cur))) | (1 << cur);
	res = max(res, cur);
}

void solve()
{
	// lg[1] = 0;
	// rep(i, 2, (1 << 16 - 1)) lg[i] = lg[i / 2] + 1;
	cin >> n;
	rep(i, 1, n - 1)
	{
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	cout << res << endl;
}

#ifndef ONLINE_JUDGE
bool end_of_memory_use;
#endif

signed main()
{
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int testcase = 1;
	// cin >> testcase;
	while (testcase--)
		solve();
#ifndef ONLINE_JUDGE
	cerr << "Memory use:" << (&end_of_memory_use - &start_of_memory_use) / 1024.0 / 1024.0 << "MiB" << endl;
	cerr << "Time use:" << (double)clock() / CLOCKS_PER_SEC * 1000.0 << "ms" << endl;
#endif
	return 0;
}
```