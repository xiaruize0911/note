#多重背包 #二进制分组 #背包dp #dp 

$dp_{i,j}$ 表示 $sum-len=i,sum=j$ 是否可行

发现在题目的 $\lfloor \dfrac{S}{5} \rfloor$ 的限制下，$dp_i$ 中值为 ``true``的 $j$ 是连续的，可以用一个 ``vector`` 维护连续段的左右端点

转移是一个多重背包，进行二进制分组，这样时间复杂度就是 $\mathcal{O}(SlogS)$ 的

```cpp
// Author: xiaruize
#ifndef ONLINE_JUDGE
bool start_of_memory_use;
#endif
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
clock_t start_clock = clock();
#endif
#define int long long
#define ull unsigned long long

#define ALL(a) (a).begin(), (a).end()
#define pb push_back
#define mk make_pair
#define pii pair<int, int>
#define pis pair<int, string>
#define sec second
#define fir first
#define sz(a) int((a).size())
#define Yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define No cout << "No" << endl
#define NO cout << "NO" << endl
#define mms(arr, n) memset(arr, n, sizeof(arr))
#define rep(i, a, n) for (int i = (a); i <= (n); ++i)
#define per(i, n, a) for (int i = (n); i >= (a); --i)
int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}
int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MOD = 1000000007;
const int N = 2e5 + 10;

vector<pii> dp[N << 1];
int cnt[N];
int lw, up;
int n, m;

vector<pii> merge(vector<pii> a, vector<pii> b, int val)
{
	vector<pii> res;
	int x = 0, y = 0;
	int l = -1, r = -1;
	while (x < a.size() || y < b.size())
	{
		// cerr << x << ' ' << y << endl;
		if (x < a.size() && (y == b.size() || b[y].first + val > a[x].first))
		{
			if (r >= a[x].first)
				r = max(r, a[x].second);
			else
			{
				if (r >= 0)
					res.push_back({l, r});
				l = a[x].first;
				r = a[x].second;
			}
			x++;
		}
		else
		{
			if (r >= b[y].first + val)
				r = max(r, b[y].second + val);
			else
			{
				if (r >= 0)
					res.push_back({l, r});
				l = b[y].first + val;
				r = b[y].second + val;
			}
			y++;
		}
	}
	if (l >= 0)
		res.push_back({l, r});
	return res;
}

void update(int x, int y)
{
	if (x > 0)
	{
		per(i, up, lw) dp[i + x] = merge(dp[i + x], dp[i], y);
		up += x;
	}
	else
	{
		rep(i, lw, up) dp[i + x] = merge(dp[i + x], dp[i], y);
		lw += x;
	}
}

void solve()
{
	lw = up = N;
	cin >> n >> m;
	rep(i, 1, n)
	{
		int x;
		cin >> x;
		cnt[x]++;
	}
	dp[N].push_back({0, cnt[1]});
	rep(i, 0, m)
	{
		if (i == 1)
			continue;
		if (!cnt[i])
			continue;
		for (int j = 0, mul = 1; mul < cnt[i]; j++, mul *= 2)
		{
			update(mul * (i - 1), mul);
			cnt[i] -= mul;
		}
		update((i - 1) * cnt[i], cnt[i]);
	}
	int res = 0;
	rep(i, lw, up) for (auto [l, r] : dp[i])
		res += r - l + 1;
	cout << res << endl;
}

#ifndef ONLINE_JUDGE
bool end_of_memory_use;
#endif

signed main()
{
	freopen("skew.in","r",stdin);
	freopen("skew.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int testcase = 1;
	// cin >> testcase;
	while (testcase--)
		solve();
#ifndef ONLINE_JUDGE
	cerr << "Memory use:" << (&end_of_memory_use - &start_of_memory_use) / 1024.0 / 1024.0 << "MiB" << endl;
	cerr << "Time use:" << (double)clock() / CLOCKS_PER_SEC * 1000.0 << "ms" << endl;
#endif
	return 0;
}
```